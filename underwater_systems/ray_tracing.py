# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_ray_tracing.ipynb.

# %% auto 0
__all__ = ['SSP', 'SoundParticle', 'RayTracer']

# %% ../nbs/04_ray_tracing.ipynb 2
import numpy as np
from scipy.interpolate import interp1d 
import matplotlib.pyplot as plt

import copy
import collections

# %% ../nbs/04_ray_tracing.ipynb 25
class SSP:
    """
    Defines one sound speed profile (depth (m) and speed (m/s) at each depth)
    """
    def __init__(self, depths, speeds):
        self._depths = depths
        self._speeds = speeds
        assert len(depths)==len(speeds), "depths and speeds vectors must have the same length."
    
    def get_speed_at_depth(self, depth):
        """
        Linearly interpolates 'speeds' values and its gradient

        depth: desired depth where to obtain speed and gradient

        returns:
        speed, gradient: tuple of list of (interpolated) values
        """
        dspeed_ddepth = -np.diff(self._speeds)/np.diff(self._depths)
        speed    = np.interp(depth, self._depths, self._speeds)
        gradient = np.interp(depth, self._depths[0:-1], dspeed_ddepth)        
        return speed, gradient
        
    def plot(self):
        plt.plot(self._speeds, self._depths, color='k', linewidth=3)
        plt.gca().invert_yaxis()
        plt.xlabel('sound speed (m/s)')
        plt.ylabel('depth (m)');
        
    def plot_speed_at_depth(self, d):
        self.plot()
        plt.scatter(self.get_speed_at_depth(d)[0], d, color='r',  linewidth=2)
        plt.gca().invert_yaxis()
        plt.xlabel('sound speed (m/s)')
        plt.ylabel('depth (m)');
        
class SoundParticle:
    """
    Models the movement of a sound particle along a ray.    
    
    Example usage:
    
        sp = SoundParticle(r0=0, d0=50, theta0=np.deg2rad(-1), ssp=ssp)
        print('Initial conditions:', sp)

        # initial state 
        r_t, d_t, q_t, c_t = sp.get_state()
        r, d, q, c = [], [], [], []

        # simulation times
        t0 = 0
        tf = 4
        dt = 0.01
        for t in np.arange(t0, tf, dt):  
            r.append(r_t)
            d.append(d_t)
            q.append(q_t)
            c.append(c_t)
            sp.move(dt)     
            r_t, d_t, q_t, c_t = sp.get_state()
    """
    def __init__(self, r0, d0, theta0, ssp):
        """
        r0: initial range of the source (m)
        d0: initial depth of the source (m)
        theta0: initial angle of the ray from the source (rad).
            - a negative angle corresponds to a downward starting ray
            - a positive angle corresponds to a upward starting ray
        ssp: sound speed profile. (SSP)
            - Must have properties: 'ssp._depths' and 'ssp._speeds', and method ssp.'get_speed_at_depth'   

        """
        self._r = r0  # range
        self._d = d0  # depth
        self._theta = theta0
        self._ssp = ssp
        self._c, self._dcdz = self._ssp.get_speed_at_depth(d0)
        
    def move(self, dt):        
        """
        Defines the movement of the sound particle according to Snell's law.
        
        dt: sampling time.
        """
        self._r = self._r + self._c*np.cos(self._theta)*dt
        self._d = self._d - self._c*np.sin(self._theta)*dt
        
        if self._d >= 0 and self._d < max(self._ssp._depths):   
            # apply Snell's law
            c_next = self._ssp.get_speed_at_depth(abs(self._d))[0]
            cos_theta_next = np.cos(self._theta)/self._c * c_next  # cos loses angle sign
            if cos_theta_next <= 1:
                self._theta = np.sign(self._theta)*np.arccos(cos_theta_next)
            else:                                
                self._theta = -np.sign(self._theta)*0.0001 
            self._c = c_next
        elif self._d >= max(self._ssp._depths):
            # bottom bounce
            old_r = self._r - self._c*np.cos(self._theta)*dt
            old_d = self._d + self._c*np.sin(self._theta)*dt
            vector   = np.array([self._r, self._d]) - np.array([old_r, old_d])
            theta_next = -np.arccos(np.dot(vector, [1, 0])/np.linalg.norm(vector))  
            self._theta = -theta_next
            self._d = max(self._ssp._depths)
            self._c = self._ssp.get_speed_at_depth(abs(max(self._ssp._depths)))[0]

        else:
            # surface bounce
            old_r = self._r - self._c*np.cos(self._theta)*dt
            old_d = self._d + self._c*np.sin(self._theta)*dt
            vector   = np.array([self._r, self._d]) - np.array([old_r, old_d])
            theta_next = -np.arccos(np.dot(vector, [1, 0])/np.linalg.norm(vector))   
            self._theta = theta_next
            self._d = 0
            self._c = self._ssp.get_speed_at_depth(abs(self._d))[0]
        
        
    def get_state(self):
        return self._r, self._d, self._theta, self._c
    
    def __str__(self):
        return f"range (m): {self._r:.2f}, depth (m): {self._d:.2f}, angle (deg): {np.rad2deg(self._theta):.2f}, speed (m/s): {self._c:.2f}"

# %% ../nbs/04_ray_tracing.ipynb 33
class RayTracer:
    def __init__(self, time, source_depth, min_range, thetas, ssp):
        """
        time        : simulation time as [t0, tf, dt]
        source_depth: depth of the source in m
        min_range:    min_range from source in m
        thetas:       range of tx angles (deg). E.g. thetas=range(5, -5, -1)
        ssp:          sound speed profile (defined using class SSP)
        """
        self.t0           = time[0]
        self.tf           = time[1]
        self.dt           = time[2]
        self.source_depth = source_depth
        self.min_range    = min_range      
        self.thetas       = np.deg2rad(thetas)
        self.ssp          = ssp
        
    def run(self):        
        for theta0 in self.thetas:
            sp = SoundParticle(r0 = self.min_range, 
                               d0 = self.source_depth,
                               theta0 = theta0, 
                               ssp = self.ssp)
            # print('Initial conditions:', sp)

            # initial state 
            r_t, d_t, q_t, c_t = sp.get_state()
            r, d, q, c = [], [], [], []

            # simulation times
            t0 = 0
            tf = 4
            dt = 0.01
            for t in np.arange(self.t0, self.tf, self.dt):  
                r.append(r_t)
                d.append(d_t)
                q.append(q_t)
                c.append(c_t)
                sp.move(dt)     
                # print(sp)
                r_t, d_t, q_t, c_t = sp.get_state()

            ##
            ## Plot
            plt.scatter(r[0], d[0], color='r', linewidth=3)
            plt.plot(r, np.array(d), color='k')
            plt.ylim((min(self.ssp._depths), max(self.ssp._depths)))
            plt.gca().invert_yaxis()
            plt.xlabel('Range (m)')
            plt.ylabel('Depth (m)');
